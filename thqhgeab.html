<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Sand Tetris with Physics</title>
<style>
body {margin:0; background:#0d0d0d; display:flex; justify-content:center; align-items:center; height:100vh;}
canvas {border:3px solid #333; image-rendering:pixelated;}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const COLS=10, ROWS=20, SCALE=30;
const EMPTY=0, SAND=1;

const BASE_SAND=[null,[240,240,0],[0,240,240],[160,0,240],[240,160,0],[0,0,240],[0,240,0],[240,0,0]];

const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
canvas.width=COLS*SCALE;
canvas.height=ROWS*SCALE;

// Tetromino shapes
const SHAPES=[
[[1,1,1,1],[0,0,0,0],[0,0,0,0],[0,0,0,0]],
[[1,1,0,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
[[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
[[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
[[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
[[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
[[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]
];

let arena = Array.from({length:ROWS},()=>Array(COLS).fill(EMPTY));
let piece = null;
let dropCounter=0;
let dropInterval=500;
let lastTime=0;

// spawn tetromino
function spawnPiece(){
    const t=Math.floor(Math.random()*SHAPES.length);
    return {shape:SHAPES[t],x:3,y:0,color:t+1};
}

// reset game
function reset(){
    arena.forEach(row=>row.fill(EMPTY));
    piece = spawnPiece();
}
reset();

// collision
function collide(px,py,s){
    for(let y=0;y<4;y++)
        for(let x=0;x<4;x++){
            if(s[y][x]){
                const cx=px+x, cy=py+y;
                if(cx<0||cx>=COLS||cy>=ROWS) return true;
                if(cy>=0 && arena[cy][cx]) return true;
            }
        }
    return false;
}

// merge piece into arena and push sand
function merge(){
    for(let y=0;y<4;y++){
        for(let x=0;x<4;x++){
            if(piece.shape[y][x]){
                const cx=piece.x+x, cy=piece.y+y;
                if(cy>=0){
                    // push sand down if block lands on sand
                    if(arena[cy][cx]===SAND){
                        pushSand(cx,cy);
                    }
                    arena[cy][cx]=piece.color;
                }
            }
        }
    }
}

// push sand sideways when a block lands
function pushSand(x,y){
    for(let i=0;i<ROWS-y;i++){
        const sy=y+i;
        if(sy+1>=ROWS) break;
        if(arena[sy+1][x]===EMPTY){
            arena[sy+1][x]=SAND;
            arena[sy][x]=EMPTY;
        } else {
            if(x>0 && arena[sy+1][x-1]===EMPTY){
                arena[sy+1][x-1]=SAND;
                arena[sy][x]=EMPTY;
            } else if(x<COLS-1 && arena[sy+1][x+1]===EMPTY){
                arena[sy+1][x+1]=SAND;
                arena[sy][x]=EMPTY;
            }
        }
    }
}

// clear full lines
function clearLines(){
    for(let y=ROWS-1;y>=0;y--){
        if(arena[y].every(v=>v!==EMPTY)){
            arena.splice(y,1);
            arena.unshift(Array(COLS).fill(EMPTY));
            y++;
        }
    }
}

// move piece
function move(dir){
    piece.x+=dir;
    if(collide(piece.x,piece.y,piece.shape)) piece.x-=dir;
}

// rotate piece
function rotatePiece(){
    const s = piece.shape;
    const n = s[0].map((_,i)=>s.map(r=>r[i]).reverse());
    const oldX = piece.x;
    piece.shape = n;
    if(collide(piece.x,piece.y,piece.shape)) piece.x=oldX;
}

// drop piece
function drop(){
    piece.y++;
    if(collide(piece.x,piece.y,piece.shape)){
        piece.y--;
        merge();
        clearLines();
        piece = spawnPiece();
        if(collide(piece.x,piece.y,piece.shape)) reset();
    }
    dropCounter=0;
}

// sand physics
function sandPhysics(){
    for(let y=ROWS-2;y>=0;y--){
        for(let x=0;x<COLS;x++){
            if(arena[y][x]===SAND){
                if(arena[y+1][x]===EMPTY){
                    arena[y+1][x]=SAND;
                    arena[y][x]=EMPTY;
                } else if(x>0 && arena[y+1][x-1]===EMPTY){
                    arena[y+1][x-1]=SAND;
                    arena[y][x]=EMPTY;
                } else if(x<COLS-1 && arena[y+1][x+1]===EMPTY){
                    arena[y+1][x+1]=SAND;
                    arena[y][x]=EMPTY;
                }
            }
        }
    }
}

// draw everything
function draw(){
    ctx.fillStyle="#0d0d0d";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // arena
    for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
            if(arena[y][x]){
                let c=arena[y][x]===SAND ? BASE_SAND[1] : BASE_SAND[arena[y][x]];
                ctx.fillStyle=`rgb(${c[0]},${c[1]},${c[2]})`;
                ctx.fillRect(x*SCALE,y*SCALE,SCALE,SCALE);
            }
        }
    }

    // piece
    for(let y=0;y<4;y++)
        for(let x=0;x<4;x++)
            if(piece.shape[y][x]){
                const c=BASE_SAND[piece.color];
                ctx.fillStyle=`rgb(${c[0]},${c[1]},${c[2]})`;
                ctx.fillRect((piece.x+x)*SCALE,(piece.y+y)*SCALE,SCALE,SCALE);
            }
}

// main loop
function update(time=0){
    const delta = time-lastTime;
    lastTime = time;
    dropCounter += delta;
    if(dropCounter>dropInterval) drop();
    sandPhysics();
    draw();
    requestAnimationFrame(update);
}

// controls
document.addEventListener("keydown",e=>{
    if(e.key==="ArrowLeft") move(-1);
    if(e.key==="ArrowRight") move(1);
    if(e.key==="ArrowDown") drop();
    if(e.key===" ") rotatePiece();
    if(e.key==="s") {
        // spawn sand at random column
        const x=Math.floor(Math.random()*COLS);
        arena[0][x]=SAND;
    }
    if(e.key==="r") reset();
});

update();
</script>
</body>
</html>
