<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Animated Shooter with More Enemies</title>
<style>
  body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let keys = {};
document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

let score = 0;
let gameOver = false;
const gravity = 0.7;
const groundLevel = canvas.height - 50;

// --- Classes ---
class Player {
    constructor() {
        this.width = 50;
        this.height = 50;
        this.x = 100;
        this.y = groundLevel - this.height;
        this.speed = 6;
        this.velocityY = 0;
        this.onGround = true;
        this.bullets = [];
        this.fireRate = 300;
        this.lastShot = 0;
        this.health = 3;
        this.color = 'lime';
        this.animationOffset = 0;
    }

    move() {
        let moving = false;
        if (keys['ArrowLeft'] && this.x > 0) { this.x -= this.speed; moving = true; }
        if (keys['ArrowRight'] && this.x + this.width < canvas.width) { this.x += this.speed; moving = true; }
        if (keys['ArrowUp'] && this.onGround) { this.velocityY = -15; this.onGround = false; }

        this.y += this.velocityY;
        this.velocityY += gravity;

        if (this.y + this.height >= groundLevel) {
            this.y = groundLevel - this.height;
            this.velocityY = 0;
            this.onGround = true;
        }

        this.animationOffset = moving && this.onGround ? Math.sin(Date.now()/100)*5 : 0;
    }

    shoot() {
        if (keys[' ']) {
            if (Date.now() - this.lastShot > this.fireRate) {
                this.bullets.push(new Bullet(this.x + this.width, this.y + this.height/2));
                this.lastShot = Date.now();
            }
        }
    }

    update() {
        this.move();
        this.shoot();
        this.bullets.forEach(b => b.update());
        this.bullets = this.bullets.filter(b => !b.offscreen);
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y + this.animationOffset, this.width, this.height);
        this.bullets.forEach(b => b.draw());
        for (let i = 0; i < this.health; i++) {
            ctx.fillStyle = 'red';
            ctx.fillRect(20 + i * 30, 60, 20, 20);
        }
    }
}

class Bullet {
    constructor(x, y) {
        this.width = 20;
        this.height = 8;
        this.x = x;
        this.y = y;
        this.speed = 12;
        this.offscreen = false;
        this.color = 'yellow';
    }

    update() { this.x += this.speed; if (this.x > canvas.width) this.offscreen = true; }
    draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); }
}

class Enemy {
    constructor(type=0) {
        this.type = type;
        this.width = type === 0 ? 50 : type === 1 ? 50 : 40;
        this.height = type === 0 ? 50 : type === 1 ? 50 : 30;
        this.speed = type === 0 ? 2 + Math.random()*1 : type === 1 ? 3 : 4;
        this.health = type===0 ? 1 : type===1 ? 3 : 2;
        this.baseColor = type===0 ? 'red' : type===1 ? 'orange' : 'purple';
        this.x = canvas.width + Math.random()*300;
        this.y = type === 2 ? groundLevel - 150 - Math.random()*100 : groundLevel - this.height; // flying enemies
        this.offscreen = false;
        this.wigglePhase = Math.random()*Math.PI*2;
    }

    update() {
        this.x -= this.speed;
        this.wigglePhase += 0.1;
        if (this.x + this.width < 0) this.offscreen = true;
    }

    draw() {
        ctx.fillStyle = this.baseColor;
        ctx.fillRect(this.x, this.y + Math.sin(this.wigglePhase)*5, this.width, this.height);
        ctx.fillStyle = 'pink';
        ctx.fillRect(this.x, this.y - 8 + Math.sin(this.wigglePhase)*5, this.width*(this.health / (this.type===0?1:this.type===1?3:2)), 5);
    }
}

class PowerUp {
    constructor(x, y, type) { this.x=x; this.y=y; this.width=30; this.height=30; this.type=type; this.speed=3; this.collected=false; this.bouncePhase=Math.random()*Math.PI*2; }
    update() { this.x -= this.speed; this.bouncePhase+=0.1; if (this.x+this.width<0) this.collected=true; }
    draw() { ctx.fillStyle=this.type==='health'?'pink':'cyan'; ctx.fillRect(this.x,this.y+Math.sin(this.bouncePhase)*5,this.width,this.height); }
}

class BackgroundLayer {
    constructor(color,speed) { this.color=color; this.speed=speed; this.x=0; }
    update() { this.x-=this.speed; if(this.x<=-canvas.width)this.x=0; }
    draw() { ctx.fillStyle=this.color; ctx.fillRect(this.x,0,canvas.width,canvas.height); ctx.fillRect(this.x+canvas.width,0,canvas.width,canvas.height); }
}

// --- Game Setup ---
let player = new Player();
let enemies = [];
let powerUps = [];
let enemySpawnTimer = 0;
let powerUpTimer = 0;

let backgroundObjects = [ new BackgroundLayer('#333',0.2), new BackgroundLayer('#444',0.5), new BackgroundLayer('#555',1) ];

function detectCollision(a,b){ return a.x<b.x+b.width && a.x+a.width>b.x && a.y<b.y+b.height && a.y+a.height>b.y; }

function spawnEnemies(){
    enemySpawnTimer++;
    if(enemySpawnTimer>80){
        let rand = Math.random();
        let type = rand<0.5?0: rand<0.8?1:2; // 50% type0, 30% type1, 20% flying type2
        enemies.push(new Enemy(type));
        enemySpawnTimer=0;
    }
}

function spawnPowerUps(){ powerUpTimer++; if(powerUpTimer>600){ let type=Math.random()<0.5?'health':'rapid'; let y=groundLevel-80-Math.random()*100; powerUps.push(new PowerUp(canvas.width,y,type)); powerUpTimer=0; } }

function updateGameObjects(){
    spawnEnemies(); spawnPowerUps();
    enemies.forEach((enemy,eIndex)=>{
        enemy.update();
        player.bullets.forEach((bullet,bIndex)=>{
            if(detectCollision(bullet,enemy)){
                enemy.health--; player.bullets.splice(bIndex,1);
                if(enemy.health<=0){ enemies.splice(eIndex,1); score+=enemy.type===0?10:enemy.type===1?30:20; }
            }
        });
        if(detectCollision(player,enemy)){ player.health--; enemies.splice(eIndex,1); if(player.health<=0) gameOver=true; }
    });
    powerUps.forEach((p,pIndex)=>{
        p.update();
        if(detectCollision(player,p)){
            if(p.type==='health' && player.health<3) player.health++;
            if(p.type==='rapid') player.fireRate=100;
            setTimeout(()=>player.fireRate=300,5000);
            powerUps.splice(pIndex,1);
        }
    });
    enemies=enemies.filter(e=>!e.offscreen);
    powerUps=powerUps.filter(p=>!p.collected);
}

function drawGround(){ ctx.fillStyle='#222'; ctx.fillRect(0,groundLevel,canvas.width,canvas.height-groundLevel); }
function drawScore(){ ctx.fillStyle='white'; ctx.font='28px Arial'; ctx.fillText('Score: '+score,20,40); }

function gameLoop(){
    if(gameOver){ ctx.fillStyle='black'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='red'; ctx.font='60px Arial'; ctx.fillText('GAME OVER',canvas.width/2-180,canvas.height/2); ctx.font='36px Arial'; ctx.fillText('Score: '+score,canvas.width/2-70,canvas.height/2+60); return; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    backgroundObjects.forEach(layer=>{ layer.update(); layer.draw(); });
    drawGround();
    player.update(); player.draw();
    updateGameObjects();
    enemies.forEach(e=>e.draw());
    powerUps.forEach(p=>p.draw());
    drawScore();
    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
