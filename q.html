<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Sand Tetris v2</title>
<style>
body {
  background:#0e0e0e;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
  margin:0;
}
canvas {
  background:#000;
  image-rendering: pixelated;
  border:2px solid #444;
}
</style>
</head>
<body>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const cols = 12;
const rows = 20;
const scale = 20;

canvas.width = cols * scale;
canvas.height = rows * scale;

// 0 = empty, 1 = sand, 2 = stone
const COLORS = {
  1: "#f5c542",
  2: "#888888"
};

let grid = Array.from({length: rows}, () =>
  Array(cols).fill(0)
);

const SHAPES = [
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[0,1,0],[1,1,1]],
  [[1,0,0],[1,1,1]],
  [[0,0,1],[1,1,1]],
  [[0,1,1],[1,1,0]],
  [[1,1,0],[0,1,1]]
];

function newPiece() {
  const shape = SHAPES[Math.floor(Math.random()*SHAPES.length)];
  const material = Math.random() < 0.3 ? 2 : 1; // 30% stone
  return {
    shape,
    mat: material,
    x: Math.floor(cols/2) - Math.floor(shape[0].length/2),
    y: 0
  };
}

let piece = newPiece();

function collide(p) {
  for (let y=0;y<p.shape.length;y++) {
    for (let x=0;x<p.shape[y].length;x++) {
      if (p.shape[y][x]) {
        if (
          grid[y+p.y]?.[x+p.x] !== 0
        ) return true;
      }
    }
  }
  return false;
}

function merge() {
  piece.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if (v) grid[y+piece.y][x+piece.x] = piece.mat;
    });
  });
}

function rotate() {
  const r = piece.shape[0].map((_,i)=>
    piece.shape.map(r=>r[i]).reverse()
  );
  const old = piece.shape;
  piece.shape = r;
  if (collide(piece)) piece.shape = old;
}

function clearLines() {
  grid = grid.filter(r => r.some(c => c === 0));
  while (grid.length < rows)
    grid.unshift(Array(cols).fill(0));
}

/* ---- MATERIAL PHYSICS ---- */
function updatePhysics() {
  for (let y = rows-2; y >= 0; y--) {
    for (let x = 0; x < cols; x++) {
      const cell = grid[y][x];
      if (!cell) continue;

      // stone: heavy, straight down only
      if (cell === 2) {
        if (!grid[y+1][x]) {
          grid[y][x] = 0;
          grid[y+1][x] = 2;
        }
      }

      // sand: slide + fall
      if (cell === 1) {
        if (!grid[y+1][x]) {
          grid[y][x] = 0;
          grid[y+1][x] = 1;
        } else {
          const d = Math.random() < 0.5 ? -1 : 1;
          if (grid[y+1][x+d] === 0) {
            grid[y][x] = 0;
            grid[y+1][x+d] = 1;
          }
        }
      }
    }
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  grid.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if (v) {
        ctx.fillStyle = COLORS[v];
        ctx.fillRect(x*scale,y*scale,scale,scale);
      }
    });
  });

  piece.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if (v) {
        ctx.fillStyle = COLORS[piece.mat];
        ctx.fillRect(
          (x+piece.x)*scale,
          (y+piece.y)*scale,
          scale,scale
        );
      }
    });
  });
}

let drop = 0;
let last = 0;

function update(t=0) {
  const dt = t-last;
  last = t;
  drop += dt;

  if (drop > 500) {
    piece.y++;
    if (collide(piece)) {
      piece.y--;
      merge();
      clearLines();
      piece = newPiece();
    }
    drop = 0;
  }

  updatePhysics();
  draw();
  requestAnimationFrame(update);
}

document.addEventListener("keydown", e=>{
  if (e.key==="ArrowLeft") {
    piece.x--; if (collide(piece)) piece.x++;
  }
  if (e.key==="ArrowRight") {
    piece.x++; if (collide(piece)) piece.x--;
  }
  if (e.key==="ArrowDown") {
    piece.y++; if (collide(piece)) piece.y--;
  }
  if (e.key==="ArrowUp") rotate();
});

update();
</script>
</body>
</html>
