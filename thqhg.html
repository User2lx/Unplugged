<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>4x4 Block Tetris</title>
<style>
body{margin:0;background:#0d0d0d;display:flex;justify-content:center;align-items:center;height:100vh;}
canvas{border:3px solid #333;image-rendering:pixelated;}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
/* CONFIG */
const COLS=10,ROWS=20,BLOCK=4; // each tetromino = 4x4 cells
let SCALE=20; // pixel size per block
const canvas=document.getElementById("c"),ctx=canvas.getContext("2d");
canvas.width=COLS*BLOCK*SCALE;
canvas.height=ROWS*BLOCK*SCALE;

/* COLORS */
const COLORS=["#000","#f0f","#0ff","#ff0","#f80","#08f","#0f0","#f00"];

/* SHAPES 4x4 */
const SHAPES=[
  [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], // I
  [[0,0,0,0],[0,2,2,0],[0,2,2,0],[0,0,0,0]], // O
  [[0,0,0,0],[0,3,0,0],[3,3,3,0],[0,0,0,0]], // T
  [[0,0,0,0],[4,0,0,0],[4,4,4,0],[0,0,0,0]], // L
  [[0,0,0,0],[0,0,5,0],[5,5,5,0],[0,0,0,0]], // J
  [[0,0,0,0],[0,6,6,0],[6,6,0,0],[0,0,0,0]], // S
  [[0,0,0,0],[7,7,0,0],[0,7,7,0],[0,0,0,0]]  // Z
];

let arena = Array.from({length:ROWS},()=>Array(COLS).fill(0));
let piece = spawn();
let dropCounter=0,dropInterval=500;
let lastTime=0;

/* SPAWN PIECE */
function spawn(){
  const type=Math.floor(Math.random()*SHAPES.length);
  return {shape:SHAPES[type],x:3,y:0,color:type+1};
}

/* COLLISION */
function collide(arena,piece){
  for(let y=0;y<4;y++){
    for(let x=0;x<4;x++){
      if(piece.shape[y][x]!==0){
        const px=piece.x+x;
        const py=piece.y+y;
        if(py>=ROWS||px<0||px>=COLS||arena[py][px]!==0) return true;
      }
    }
  }
  return false;
}

/* MERGE PIECE */
function merge(arena,piece){
  for(let y=0;y<4;y++)
    for(let x=0;x<4;x++)
      if(piece.shape[y][x]!==0) arena[piece.y+y][piece.x+x]=piece.color;
}

/* CLEAR LINES */
function clearLines(){
  for(let y=ROWS-1;y>=0;y--){
    if(arena[y].every(v=>v!==0)){
      arena.splice(y,1);
      arena.unshift(Array(COLS).fill(0));
      y++;
    }
  }
}

/* MOVE PIECE */
function move(dir){
  piece.x+=dir;
  if(collide(arena,piece)) piece.x-=dir;
}

/* ROTATE PIECE */
function rotatePiece(){
  const s=piece.shape;
  const n=s[0].map((_,i)=>s.map(r=>r[i]).reverse());
  const oldX=piece.x;
  piece.shape=n;
  if(collide(arena,piece)) piece.x=oldX;
}

/* DROP */
function drop(){
  piece.y++;
  if(collide(arena,piece)){
    piece.y--;
    merge(arena,piece);
    clearLines();
    piece=spawn();
    if(collide(arena,piece)) arena.forEach(row=>row.fill(0)); // reset game
  }
  dropCounter=0;
}

/* DRAW */
function draw(){
  ctx.fillStyle="#0d0d0d";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // arena
  for(let y=0;y<ROWS;y++)
    for(let x=0;x<COLS;x++)
      if(arena[y][x]!==0){
        ctx.fillStyle=COLORS[arena[y][x]];
        ctx.fillRect(x*BLOCK*SCALE,y*BLOCK*SCALE,BLOCK*SCALE,BLOCK*SCALE);
      }

  // current piece
  for(let y=0;y<4;y++)
    for(let x=0;x<4;x++)
      if(piece.shape[y][x]!==0){
        ctx.fillStyle=COLORS[piece.color];
        ctx.fillRect((piece.x+x)*BLOCK*SCALE,(piece.y+y)*BLOCK*SCALE,BLOCK*SCALE,BLOCK*SCALE);
      }
}

/* LOOP */
function update(time=0){
  const delta=time-lastTime;
  lastTime=time;
  dropCounter+=delta;
  if(dropCounter>dropInterval) drop();
  draw();
  requestAnimationFrame(update);
}

/* INPUT */
document.addEventListener("keydown",e=>{
  if(e.key==="ArrowLeft") move(-1);
  if(e.key==="ArrowRight") move(1);
  if(e.key==="ArrowDown") drop();
  if(e.key===" ") rotatePiece();
});

update();
</script>
</body>
</html>
