<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Full Side Scroller Shooter</title>
<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#87ceeb;}
  canvas{display:block;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById("game"),ctx=canvas.getContext("2d");
function resize(){canvas.width=window.innerWidth;canvas.height=window.innerHeight;}
window.addEventListener("resize",resize);resize();

// ===== Player =====
const player={x:100,y:0,w:40,h:50,dx:0,dy:0,grounded:false,speed:5,jump:12,health:5,maxHealth:5,facing:1};

// ===== Controls =====
const keys={};
window.addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
window.addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

// ===== Camera =====
let camX=0;

// ===== World =====
let CHUNK=400,ground=[],platforms=[],hazards=[],particles=[],enemies=[],upgrades=[],bullets=[],enemyBullets=[];

// ===== Biomes =====
const biomes=[
  {bg:"#87ceeb",ground:"#2ecc71",platform:"#27ae60",hazard:"spike",particle:"#2ecc71",bullet:"#fff"},
  {bg:"#f6d365",ground:"#27ae60",platform:"#27ae60",hazard:"quicksand",particle:"#f1c40f",bullet:"#0ff"},
  {bg:"#ff6b6b",ground:"#c0392b",platform:"#e74c3c",hazard:"lava",particle:"#ff4500",bullet:"#f90"},
  {bg:"#c7ecee",ground:"#16a085",platform:"#1abc9c",hazard:"icepatch",particle:"#fff",bullet:"#0f0"}
];
let currentBiomeIndex=-1;

// ===== Score =====
let distanceScore=0,enemyScore=0;

// ===== Respawn Timer =====
let respawnTimer = 0; // counts frames until player can move again
const RESPAWN_DELAY = 60; // 60 frames â‰ˆ 1 second

// ===== Init World =====
function initWorld(){
  ground=[{x:0,y:canvas.height-50,w:canvas.width*2,h:50}];
  platforms=[{x:150,y:canvas.height-150,w:100,h:20,color:biomes[0].platform},{x:350,y:canvas.height-200,w:100,h:20,color:biomes[0].platform}];
  player.x=100;player.y=canvas.height-50-player.h;
  generateAhead();
}

// ===== Biome helper =====
function getBiome(chunkIdx){return biomes[Math.floor(chunkIdx/50)%biomes.length];}

// ===== Spawn enemy =====
function spawnEnemy(x,y,type){
  let hp = type==="boss"?20:type==="fast"?2:1;
  enemies.push({x,y,w:type==="boss"?80:40,h:type==="boss"?80:40,hp,maxHp:hp,dx:type==="fast"?3:1,type,shootCooldown:60});
}

// ===== Generate chunks =====
function generateAhead(){
  const chunkIdx=Math.floor(player.x/CHUNK);
  const biome=getBiome(chunkIdx);
  if(chunkIdx!==currentBiomeIndex) currentBiomeIndex=chunkIdx;

  // Ground
  while(ground[ground.length-1].x<player.x+canvas.width*2){
    const last=ground[ground.length-1];
    ground.push({x:last.x+last.w,y:canvas.height-50,w:800,h:50});
  }

  // Platforms
  while(platforms[platforms.length-1].x<player.x+canvas.width){
    const last=platforms[platforms.length-1];
    const x=last.x+last.w+Math.random()*150+50;
    const y=canvas.height-150-Math.random()*120;
    platforms.push({x,y,w:100,h:20,color:biome.platform});
  }

  // Enemies: spawn once per chunk
  if(!enemies.some(e=>Math.floor(e.x/CHUNK)===chunkIdx)){
    const typeRand=Math.random();
    const type=typeRand<0.1?"boss":typeRand<0.4?"fast":"normal";
    const x=chunkIdx*CHUNK+200+Math.random()*200;
    const y=platforms[platforms.length-1].y-40;
    spawnEnemy(x,y,type);
  }

  // Hazards
  while(hazards.length===0 || hazards[hazards.length-1].x<player.x+canvas.width){
    const last=hazards.length?hazards[hazards.length-1]:{x:0};
    const x=last.x+200+Math.random()*300;
    const y=biome.hazard==="spike"?platforms[platforms.length-1].y-10:canvas.height-50;
    hazards.push({x,y,w:50,h:biome.hazard==="spike"?10:biome.hazard==="quicksand"?50:biome.hazard==="lava"?50:20,type:biome.hazard});
  }

  // Upgrades
  if(upgrades.length<1){
    const x=player.x+600+Math.random()*150;
    upgrades.push({x,y:platforms[platforms.length-1].y-50,w:25,h:25});
  }
}

// ===== Shooting =====
let shootCooldown=0;
function shoot(){
  if(shootCooldown>0) return;
  const biome=getBiome(Math.floor(player.x/CHUNK));
  bullets.push({x:player.facing===1?player.x+player.w:player.x-10,y:player.y+player.h/2-5,w:10,h:10,dx:15*player.facing,color:biome.bullet});
  shootCooldown=10;
}

// ===== Enemy shooting =====
function enemyShoot(e){
  const biome=getBiome(Math.floor(player.x/CHUNK));
  const dx=(player.x+player.w/2-e.x-e.w/2)/20;
  const dy=(player.y+player.h/2-e.y-e.h/2)/20;
  enemyBullets.push({x:e.x+e.w/2,y:e.y+e.h/2,w:10,h:10,dx,dy,color:biome.bullet});
}

// ===== Particle system =====
function createParticles(x,y,color,count=5){
  for(let i=0;i<count;i++){
    particles.push({x,y,dx:(Math.random()-0.5)*4,dy:(Math.random()-0.5)*4,life:30,type:color});
  }
}

// ===== Upgrades =====
function applyUpgrade(){
  const roll=Math.floor(Math.random()*3);
  if(roll===0){player.maxHealth++;player.health=player.maxHealth;}
  else if(roll===1){player.speed+=0.5;}
  else{player.jump+=2;}
  createParticles(player.x,player.y,"#f1c40f");
}

// ===== Update =====
function update(){
  // Prevent player input during respawn
  if(respawnTimer <= 0){
    // Controls
    player.dx=(keys['a']?-1:0)+(keys['d']?1:0); 
    player.dx*=player.speed;
    if((keys['w']||keys[' ']) && player.grounded){player.dy=-player.jump;player.grounded=false;}
    if(keys['j']) shoot();
  } else {
    respawnTimer--; // count down until input allowed
  }

  // Physics
  player.dy+=0.6; player.x+=player.dx; player.y+=player.dy; player.grounded=false;
  [...ground,...platforms].forEach(p=>{
    if(player.x+player.w>p.x && player.x<p.x+p.w && player.y+player.h>=p.y && player.y+player.h<=p.y+20){
      player.y=p.y-player.h; player.dy=0; player.grounded=true;
    }
  });

  // Camera
  camX=Math.max(0,player.x-canvas.width/4);

  // Offscreen cleanup
  ground=ground.filter(g=>g.x+g.w>camX-100);
  platforms=platforms.filter(p=>p.x+p.w>camX-100);
  hazards=hazards.filter(h=>h.x+h.w>camX-100);
  upgrades=upgrades.filter(u=>u.x+u.w>camX-100);
  bullets=bullets.filter(b=>b.x+b.w>camX-500 && b.x<player.x+canvas.width+500);
  enemyBullets=enemyBullets.filter(b=>b.x+b.w>camX-500 && b.x<player.x+canvas.width+500 && b.y+b.h>0 && b.y<canvas.height);
  enemies=enemies.filter(e=>e.x+e.w>camX-1000 && e.x<player.x+canvas.width+500);

  // Move bullets
  bullets.forEach(b=>b.x+=b.dx);
  enemyBullets.forEach(b=>{b.x+=b.dx;b.y+=b.dy;});

  // Enemy AI and shooting
  enemies.forEach(e=>{
    e.x+=e.dx*(e.type==="fast"?2:1);
    if(e.type==="boss"){ e.shootCooldown--; if(e.shootCooldown<=0){enemyShoot(e);e.shootCooldown=60;} }

    // Bullet collision
    bullets.forEach((b,i)=>{
      if(b.x+b.w>e.x && b.x<e.x+e.w && b.y+b.h>e.y && b.y<e.y+e.h && e.hp>0){
        e.hp--;
        bullets.splice(i,1); // <-- DELETE the bullet after hitting enemy
        createParticles(e.x+e.w/2,e.y+e.h/2,"#f00");
        if(e.hp<=0){enemyScore+=e.type==="boss"?100:e.type==="fast"?20:10;}
      }
    });
  });

  // Remove dead enemies
  enemies=enemies.filter(e=>e.hp>0);

  // Enemy bullets damage player
  enemyBullets.forEach(b=>{
    if(player.x+player.w>b.x && player.x<b.x+b.w && player.y+player.h>b.y && player.y<b.y+b.h){
      player.health--; b.dx=0; b.dy=0;
      createParticles(player.x,player.y,"#ff0");
      if(player.health<=0) reset();
    }
  });

  // Upgrades pickup
  upgrades=upgrades.filter(u=>{
    if(player.x+player.w>u.x && player.x<u.x+u.w && player.y+player.h>u.y && player.y<u.y+u.h){
      applyUpgrade(); return false;
    }
    return true;
  });

  // Particles
  particles.forEach(p=>{p.x+=p.dx;p.y+=p.dy;p.life--;});
  particles=particles.filter(p=>p.life>0);

  // Generate new chunks
  generateAhead();
  distanceScore=Math.floor(player.x/CHUNK);
}

// ===== Draw =====
function draw(){
  const biome=getBiome(Math.floor(player.x/CHUNK));
  ctx.fillStyle=biome.bg; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.translate(-camX,0);

  ground.forEach(g=>{ctx.fillStyle=biome.ground;ctx.fillRect(g.x,g.y,g.w,g.h);});
  platforms.forEach(p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x,p.y,p.w,p.h);});
  hazards.forEach(h=>{ctx.fillStyle="#444";ctx.fillRect(h.x,h.y,h.w,h.h);});
  bullets.forEach(b=>{ctx.fillStyle=b.color;ctx.fillRect(b.x,b.y,b.w,b.h);});
  enemyBullets.forEach(b=>{ctx.fillStyle=b.color;ctx.fillRect(b.x,b.y,b.w,b.h);});
  upgrades.forEach(u=>{ctx.fillStyle="#f1c40f";ctx.fillRect(u.x,u.y,u.w,u.h);});
  enemies.forEach(e=>{ctx.fillStyle=e.hp>0?"#f00":"#555";ctx.fillRect(e.x,e.y,e.w,e.h);});
  particles.forEach(p=>{ctx.fillStyle=p.type;ctx.fillRect(p.x,p.y,5,5);});
  ctx.fillStyle="#ff4757"; ctx.fillRect(player.x,player.y,player.w,player.h);
  ctx.restore();

  ctx.fillStyle="#fff"; ctx.font="14px monospace";
  ctx.fillText(`HP: ${player.health}/${player.maxHealth}`,20,25);
  ctx.fillText(`Distance: ${distanceScore}`,20,45);
  ctx.fillText(`Enemy Score: ${enemyScore}`,20,65);
}

// ===== Reset =====
function reset(){
  player.x=100; player.y=canvas.height-50-player.h; player.dx=0; player.dy=0; player.grounded=false;
  player.health=player.maxHealth=5; player.speed=5; player.jump=12; player.facing=1;
  ground=[{x:0,y:canvas.height-50,w:canvas.width*2,h:50}];
  platforms=[]; hazards=[]; bullets=[]; enemyBullets=[]; enemies=[]; upgrades=[]; particles=[];
  distanceScore=0; enemyScore=0; currentBiomeIndex=-1;
  respawnTimer = RESPAWN_DELAY; // prevent movement for 1 second
  generateAhead();
}

// ===== Loop =====
initWorld();
(function loop(){update();draw();requestAnimationFrame(loop);})();
</script>
</body>
</html>
