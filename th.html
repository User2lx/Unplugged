<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pixel Sand Tetris</title>
<style>
  body {
    margin: 0;
    background: #0d0d0d;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  canvas {
    border: 3px solid #333;
    image-rendering: pixelated;
  }
</style>
</head>
<body>

<canvas id="c"></canvas>

<script>
/* =============== CONFIG =============== */
const COLS = 10;
const ROWS = 20;
const SUB  = 4;   // sand resolution (â†‘ = smoother, â†“ = faster)
const SCALE = 3;
/* ==================================== */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const SAND_W = COLS * SUB;
const SAND_H = ROWS * SUB;

canvas.width  = SAND_W * SCALE;
canvas.height = SAND_H * SCALE;

let sand;
let piece;
let gameOver = false;

/* ============ SHAPES ============ */
const SHAPES = [
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[0,1,0],[1,1,1]],
  [[1,0,0],[1,1,1]],
  [[0,0,1],[1,1,1]],
  [[0,1,1],[1,1,0]],
  [[1,1,0],[0,1,1]]
];

function rotate(m) {
  return m[0].map((_, i) => m.map(r => r[i]).reverse());
}
function pw(s) { return s[0].length; }
function ph(s) { return s.length; }

/* ============ GAME STATE ============ */
function reset() {
  sand = new Uint8Array(SAND_W * SAND_H);
  piece = spawn();
  gameOver = false;
}
reset();

function spawn() {
  const p = {
    shape: SHAPES[Math.random()*SHAPES.length|0],
    x: 3,
    y: 0
  };
  if (collide(p.x, p.y, p.shape)) gameOver = true;
  return p;
}

function collide(px, py, shape) {
  if (px < 0 || px + pw(shape) > COLS) return true;
  if (py + ph(shape) > ROWS) return true;
  return false;
}

/* ============ SAND HELPERS ============ */
function sandIndex(x, y) {
  return x + y * SAND_W;
}

function spawnSandBlock(tx, ty) {
  for (let y=0;y<SUB;y++) {
    for (let x=0;x<SUB;x++) {
      sand[sandIndex(tx*SUB+x, ty*SUB+y)] = 1;
    }
  }
}

/* ============ LOCK + LINE CLEAR ============ */
function lockPiece() {
  piece.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if (v) spawnSandBlock(piece.x+x, piece.y+y);
    });
  });
  clearLines();
  piece = spawn();
}

function clearLines() {
  for (let ty = ROWS-1; ty >= 0; ty--) {
    let full = true;
    for (let x=0;x<COLS;x++) {
      let filled = false;
      for (let sy=0;sy<SUB;sy++) {
        for (let sx=0;sx<SUB;sx++) {
          if (sand[sandIndex(x*SUB+sx, ty*SUB+sy)]) {
            filled = true;
            break;
          }
        }
        if (filled) break;
      }
      if (!filled) { full = false; break; }
    }

    if (full) explodeLine(ty);
  }
}

/* ðŸ’¥ explode line into falling sand */
function explodeLine(ty) {
  for (let y=ty*SUB;y<(ty+1)*SUB;y++) {
    for (let x=0;x<SAND_W;x++) {
      sand[sandIndex(x,y)] = 0;
    }
  }
}

/* ============ SAND PHYSICS ============ */
function updateSand() {
  for (let y=SAND_H-2;y>=0;y--) {
    for (let x=0;x<SAND_W;x++) {
      const i = sandIndex(x,y);
      if (!sand[i]) continue;

      const d  = sandIndex(x,y+1);
      const dl = x>0 ? sandIndex(x-1,y+1) : -1;
      const dr = x<SAND_W-1 ? sandIndex(x+1,y+1) : -1;

      if (!sand[d]) {
        sand[d]=1; sand[i]=0;
      } else if (dl!==-1 && !sand[dl]) {
        sand[dl]=1; sand[i]=0;
      } else if (dr!==-1 && !sand[dr]) {
        sand[dr]=1; sand[i]=0;
      }
    }
  }
}

/* ============ DRAW ============ */
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle = "#e6c45c";
  for (let i=0;i<sand.length;i++) {
    if (sand[i]) {
      const x=i%SAND_W, y=(i/SAND_W)|0;
      ctx.fillRect(x*SCALE,y*SCALE,SCALE,SCALE);
    }
  }

  if (!gameOver) {
    ctx.fillStyle = "#ffd800";
    piece.shape.forEach((row,y)=>{
      row.forEach((v,x)=>{
        if (v) {
          ctx.fillRect(
            (piece.x*SUB+x*SUB)*SCALE,
            (piece.y*SUB+y*SUB)*SCALE,
            SUB*SCALE,SUB*SCALE
          );
        }
      });
    });
  }

  if (gameOver) {
    ctx.fillStyle = "#ff4444";
    ctx.font = "24px monospace";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
    ctx.font = "14px monospace";
    ctx.fillText("Press R to restart", canvas.width/2, canvas.height/2+24);
  }
}

/* ============ LOOP ============ */
let drop = 0;
function loop() {
  if (!gameOver) {
    drop++;
    if (drop>25) {
      if (!collide(piece.x,piece.y+1,piece.shape)) piece.y++;
      else lockPiece();
      drop=0;
    }
    updateSand();
  }
  draw();
  requestAnimationFrame(loop);
}

/* ============ INPUT ============ */
document.addEventListener("keydown",e=>{
  if (gameOver && e.key==="r") reset();

  if (gameOver) return;

  if (e.key==="ArrowLeft" && !collide(piece.x-1,piece.y,piece.shape)) piece.x--;
  if (e.key==="ArrowRight" && !collide(piece.x+1,piece.y,piece.shape)) piece.x++;
  if (e.key==="ArrowDown" && !collide(piece.x,piece.y+1,piece.shape)) piece.y++;

  if (e.key===" ") {
    const r = rotate(piece.shape);
    if (!collide(piece.x,piece.y,r)) piece.shape=r;
    else if (!collide(piece.x-1,piece.y,r)) { piece.x--; piece.shape=r; }
    else if (!collide(piece.x+1,piece.y,r)) { piece.x++; piece.shape=r; }
  }
});

loop();
</script>
</body>
</html>
