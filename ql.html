<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Hi-Res Sand Tetris</title>
<style>
body {
  margin:0;
  background:#0d0d0d;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
}
canvas {
  image-rendering: pixelated;
  background:#000;
  border:2px solid #444;
}
</style>
</head>
<body>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

/* ---- TETRIS GRID ---- */
const tCols = 10;
const tRows = 20;
const cellSize = 24;

/* ---- SAND RESOLUTION ---- */
const sandRes = 4; // pixels per tetris cell
const sCols = tCols * sandRes;
const sRows = tRows * sandRes;
const pixel = cellSize / sandRes;

canvas.width = tCols * cellSize;
canvas.height = tRows * cellSize;

// 0 = empty, 1 = sand
let sand = Array.from({length:sRows},()=>Array(sCols).fill(0));

const SHAPES = [
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[0,1,0],[1,1,1]],
  [[1,0,0],[1,1,1]],
  [[0,0,1],[1,1,1]],
  [[0,1,1],[1,1,0]],
  [[1,1,0],[0,1,1]]
];

let piece = spawn();

function spawn() {
  const s = SHAPES[Math.floor(Math.random()*SHAPES.length)];
  return {
    shape:s,
    x: Math.floor(tCols/2) - Math.floor(s[0].length/2),
    y: 0
  };
}

function collide(p) {
  for (let y=0;y<p.shape.length;y++) {
    for (let x=0;x<p.shape[y].length;x++) {
      if (!p.shape[y][x]) continue;
      const sy = (p.y+y)*sandRes;
      const sx = (p.x+x)*sandRes;
      if (sy >= sRows) return true;
      for (let yy=0;yy<sandRes;yy++)
        for (let xx=0;xx<sandRes;xx++)
          if (sand[sy+yy]?.[sx+xx]) return true;
    }
  }
  return false;
}

function lockPiece() {
  piece.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if (!v) return;
      const sy = (piece.y+y)*sandRes;
      const sx = (piece.x+x)*sandRes;
      for (let yy=0;yy<sandRes;yy++)
        for (let xx=0;xx<sandRes;xx++)
          sand[sy+yy][sx+xx] = 1;
    });
  });
}

function rotate() {
  const r = piece.shape[0].map((_,i)=>
    piece.shape.map(r=>r[i]).reverse()
  );
  const o = piece.shape;
  piece.shape = r;
  if (collide(piece)) piece.shape = o;
}

/* ---- SAND PHYSICS ---- */
function updateSand() {
  for (let y=sRows-2;y>=0;y--) {
    for (let x=0;x<sCols;x++) {
      if (!sand[y][x]) continue;

      if (!sand[y+1][x]) {
        sand[y][x]=0; sand[y+1][x]=1;
      } else {
        const d = Math.random()<0.5?-1:1;
        if (sand[y+1][x+d]===0) {
          sand[y][x]=0;
          sand[y+1][x+d]=1;
        }
      }
    }
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // sand
  for (let y=0;y<sRows;y++)
    for (let x=0;x<sCols;x++)
      if (sand[y][x]) {
        ctx.fillStyle="#f5c542";
        ctx.fillRect(x*pixel,y*pixel,pixel,pixel);
      }

  // active piece (preview)
  piece.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if (!v) return;
      ctx.fillRect(
        (piece.x+x)*cellSize,
        (piece.y+y)*cellSize,
        cellSize,
        cellSize
      );
    });
  });
}

let drop=0,last=0;
function loop(t=0) {
  const dt=t-last; last=t; drop+=dt;

  if (drop>500) {
    piece.y++;
    if (collide(piece)) {
      piece.y--;
      lockPiece();
      piece=spawn();
    }
    drop=0;
  }

  updateSand();
  draw();
  requestAnimationFrame(loop);
}

document.addEventListener("keydown",e=>{
  if (e.key==="ArrowLeft") {piece.x--; if (collide(piece)) piece.x++;}
  if (e.key==="ArrowRight"){piece.x++; if (collide(piece)) piece.x--;}
  if (e.key==="ArrowDown"){piece.y++; if (collide(piece)) piece.y--;}
  if (e.key==="ArrowUp") rotate();
});

loop();
</script>
</body>
</html>
