<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Crash-Proof Full-Screen Side Scroller</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#000;}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

// ===== Resize =====
function resize(){
  canvas.width=window.innerWidth;
  canvas.height=window.innerHeight;
}
window.addEventListener("resize",resize);
resize();

// ===== Player =====
const player={
  x:100,y:0,w:40,h:50,
  dx:0,dy:0,speed:4,jump:12,
  grounded:false,canDoubleJump:true,
  dashCooldown:0,dashing:false,dashTime:0,
  health:5,maxHealth:5,
  atkDuration:10,attacking:false,atk:0,
  facing:1
};

// ===== Controls =====
const keys={};
window.addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
window.addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

// ===== World =====
const CHUNK=400;
let chunks=[];
const biomes=[
  {bg:"#87ceeb",ground:"#2ecc71"},
  {bg:"#f6d365",ground:"#27ae60"},
  {bg:"#ff6b6b",ground:"#c0392b"},
  {bg:"#c7ecee",ground:"#16a085"}
];
function getGroundY(){return canvas.height-50;}
function getBiome(idx){return biomes[idx%biomes.length];}

// ===== Chunk Generation =====
function createChunk(index){
  if(chunks.find(c=>c.index===index)) return;
  const biome=getBiome(index);
  const baseX=index*CHUNK;
  const chunk={
    index,
    ground:{x:baseX,y:getGroundY(),w:CHUNK,h:50,color:biome.ground},
    platforms:[],
    enemies:[],
    upgrades:[]
  };
  const numPlatforms=Math.floor(Math.random()*2)+1;
  for(let i=0;i<numPlatforms;i++){
    chunk.platforms.push({
      x:baseX+100+Math.random()*250,
      y:getGroundY()-50-Math.random()*70,
      w:80,h:20,color:biome.ground
    });
  }
  if(Math.random()<0.5) chunk.enemies.push({
    x:baseX+150+Math.random()*200,
    y:getGroundY()-40,
    w:40,h:40,dx:(Math.random()<0.5?-1:1),hp:1
  });
  if(Math.random()<0.3) chunk.upgrades.push({
    x:baseX+200+Math.random()*150,
    y:getGroundY()-100-Math.random()*50,
    w:25,h:25
  });
  chunks.push(chunk);
}

function generateChunks(){
  const playerChunk=Math.floor(player.x/CHUNK);
  for(let i=playerChunk-1;i<=playerChunk+2;i++) createChunk(i);
  chunks=chunks.filter(c=>c.index>=playerChunk-1 && c.index<=playerChunk+2);
}

// ===== Upgrades =====
function applyUpgrade(){
  const roll=Math.floor(Math.random()*4);
  if(roll===0){ player.maxHealth++; player.health=player.maxHealth; }
  else if(roll===1){ player.speed+=0.5; }
  else if(roll===2){ player.jump+=2; }
  else{ player.atkDuration+=5; }
}

// ===== Update =====
function update(){
  player.dx=0;
  if(keys["a"]){player.dx=-player.speed;player.facing=-1;}
  if(keys["d"]){player.dx=player.speed;player.facing=1;}

  if((keys["w"]||keys[" "]) && player.grounded){player.dy=-player.jump;player.grounded=false;player.canDoubleJump=true;}
  else if((keys["w"]||keys[" "]) && !player.grounded && player.canDoubleJump){player.dy=-player.jump;player.canDoubleJump=false;}

  if(keys["shift"] && player.dashCooldown<=0 && !player.dashing){player.dashing=true;player.dashTime=10;player.dashCooldown=30;}
  if(player.dashing){player.dx=15*player.facing;player.dashTime--; if(player.dashTime<=0) player.dashing=false;}
  if(player.dashCooldown>0) player.dashCooldown--;

  if(keys["j"] && !player.attacking){player.attacking=true;player.atk=player.atkDuration;}
  if(player.attacking && --player.atk<=0) player.attacking=false;

  player.dy+=0.6;
  player.x+=player.dx;
  player.y+=player.dy;

  generateChunks();

  player.grounded=false;
  chunks.forEach(c=>{
    [c.ground,...c.platforms].forEach(p=>{
      if(player.x+player.w>p.x && player.x<p.x+p.w && player.y+player.h>=p.y && player.y+player.h<=p.y+10){
        player.y=p.y-player.h;player.dy=0;player.grounded=true;player.canDoubleJump=true;
      }
    });

    c.enemies.forEach(e=>{
      e.x+=e.dx*2;
      if(player.x+player.w>e.x && player.x<e.x+e.w && player.y+player.h>e.y && player.y<e.y+e.h){
        player.health--; player.x-=20*player.facing; if(player.health<=0) reset();
      }
      if(player.attacking){
        const atk={x:player.x+(player.facing===1?player.w:-30),y:player.y+10,w:30,h:30};
        if(atk.x+atk.w>e.x && atk.x<e.x+e.w && atk.y+atk.h>e.y && atk.y<e.y+e.h) e.hp--;
      }
    });
    c.enemies=c.enemies.filter(e=>e.hp>0);

    c.upgrades=c.upgrades.filter(u=>{
      if(player.x+player.w>u.x && player.x<u.x+u.w && player.y+player.h>u.y && player.y<u.y+u.h){ applyUpgrade(); return false; }
      return true;
    });
  });

  if(player.y>canvas.height) reset();
}

// ===== Draw =====
function draw(){
  const biome=getBiome(Math.floor(player.x/CHUNK));
  ctx.fillStyle=biome.bg; ctx.fillRect(0,0,canvas.width,canvas.height);

  const camX=Math.max(0,player.x-canvas.width/3);
  ctx.save(); ctx.translate(-camX,0);

  chunks.forEach(c=>{
    ctx.fillStyle=c.ground.color; ctx.fillRect(c.ground.x,c.ground.y,c.ground.w,c.ground.h);
    c.platforms.forEach(p=>{ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,p.w,p.h);});
    c.enemies.forEach(e=>{ctx.fillStyle="#2ed573"; ctx.fillRect(e.x,e.y,e.w,e.h);});
    c.upgrades.forEach(u=>{ctx.fillStyle="#f1c40f"; ctx.fillRect(u.x,u.y,u.w,u.h);});
  });

  ctx.fillStyle="#ff4757"; ctx.fillRect(player.x,player.y,player.w,player.h);
  if(player.attacking){ctx.fillStyle="#ffa502";ctx.fillRect(player.x+(player.facing===1?player.w:-30),player.y+10,30,30);}

  ctx.restore();

  ctx.fillStyle="#fff"; ctx.font="14px monospace";
  ctx.fillText(`HP: ${player.health}/${player.maxHealth}`,20,25);
  ctx.fillText(`Speed: ${player.speed.toFixed(1)}`,20,45);
  ctx.fillText(`Jump: ${player.jump}`,20,65);
  ctx.fillText(`Atk: ${player.atkDuration}`,20,85);
  ctx.fillText(`Dash CD: ${player.dashCooldown}`,20,105);
}

// ===== Reset =====
function reset(){
  player.x=100; player.y=0; player.dx=0; player.dy=0;
  player.grounded=false; player.canDoubleJump=true;
  player.health=player.maxHealth=5;
  player.speed=4; player.jump=12; player.atkDuration=10;
  player.dashCooldown=0; player.dashing=false; player.dashTime=0;
  chunks=[];
}

// ===== Loop =====
(function loop(){update();draw();requestAnimationFrame(loop);})();
</script>
</body>
</html>
